# 메모리 타임라인 페이지네이션 구현 계획

## 문제 상황
썸네일 우선 로딩으로 대역폭은 97.5% 절감했으나, 여전히 초기 로딩 시간이 길다:
- 현재: S3에서 **모든 썸네일**을 한번에 가져옴 (100+ 장)
- 문제: XML 파싱 + 100+ 객체 처리 = 느린 초기 렌더링
- 사용자 경험: 페이지 로드 후 수 초간 대기

## 목표
**초기 로딩 시간 < 1초 달성**
- 첫 렌더링: 최근 50장만 표시
- 추가 로드: 사용자 인터랙션에 따라 점진적 로드
- 기존 기능 유지: 썸네일 우선 로딩 + 클릭 시 원본 표시

## 핵심 인사이트

### S3 API 페이지네이션 지원
S3 XML API는 페이지네이션을 지원합니다:
```xml
<!-- Request -->
GET /?prefix=history/&max-keys=50&marker=history/2024-04/thumb/photo50.jpg

<!-- Response -->
<ListBucketResult>
  <IsTruncated>true</IsTruncated>
  <NextMarker>history/2024-04/thumb/photo50.jpg</NextMarker>
  <Contents>...</Contents>
</ListBucketResult>
```

**파라미터:**
- `max-keys`: 한번에 가져올 최대 객체 수
- `marker`: 시작 위치 (이전 요청의 마지막 Key)
- `IsTruncated`: 더 많은 결과가 있는지 여부
- `NextMarker`: 다음 요청에 사용할 marker

### 사용자 행동 패턴
- 대부분 사용자는 **최근 사진**부터 확인
- 오래된 사진은 필요시에만 탐색
- ∴ 최신 50장만 로드해도 80%+ 사용 케이스 충족

## 해결 방안

### 1. 점진적 로딩 전략
```
초기 렌더링 (자동)
  ↓
최근 50장 로드 (썸네일)
  ↓
사용자가 타임라인 스크롤
  ↓
하단 도달 시 다음 50장 로드
  ↓
반복 (모든 사진 로드까지)
```

### 2. 구현 방식 선택

#### Option A: "더보기" 버튼 (권장)
**장점:**
- 명시적 사용자 인터랙션
- 네트워크 요청 제어 가능
- 구현 단순 (30줄 내외)

**단점:**
- 추가 클릭 필요

#### Option B: 무한 스크롤
**장점:**
- 자연스러운 UX
- 클릭 불필요

**단점:**
- 스크롤 이벤트 처리 복잡
- Intersection Observer 필요
- 구현 복잡도 높음 (60줄+)

**선택: Option A (더보기 버튼)**
- 간단한 구현으로 빠른 효과
- 필요시 Option B로 전환 가능

## 구현 단계

### 1. lib/s3.ts 업데이트

#### 1a. 페이지네이션 파라미터 추가

```typescript
export interface S3ListOptions {
  prefix?: string;
  thumbnailsOnly?: boolean;
  maxKeys?: number;      // 새로 추가: 최대 객체 수
  marker?: string;       // 새로 추가: 시작 위치
}

export interface S3ListResult {
  objects: S3Object[];
  isTruncated: boolean;  // 더 많은 결과가 있는지
  nextMarker?: string;   // 다음 요청에 사용할 marker
}

export async function listS3Objects(
  options: S3ListOptions = {}
): Promise<S3ListResult> {
  const {
    prefix = '',
    thumbnailsOnly = false,
    maxKeys = 1000,        // 기본값: 제한 없음
    marker = undefined
  } = options;

  // URL 구성
  let url = `${BUCKET_URL}?prefix=${encodeURIComponent(prefix)}`;
  if (maxKeys) {
    url += `&max-keys=${maxKeys}`;
  }
  if (marker) {
    url += `&marker=${encodeURIComponent(marker)}`;
  }

  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to fetch S3 bucket: ${response.statusText}`);
  }

  const xmlText = await response.text();
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

  // 페이지네이션 정보 추출
  const isTruncated =
    xmlDoc.getElementsByTagName('IsTruncated')[0]?.textContent === 'true';
  const nextMarker =
    xmlDoc.getElementsByTagName('NextMarker')[0]?.textContent || undefined;

  const contents = xmlDoc.getElementsByTagName('Contents');
  const objects: S3Object[] = [];

  for (let i = 0; i < contents.length; i++) {
    const content = contents[i];
    const key = content.getElementsByTagName('Key')[0]?.textContent || '';
    const lastModified =
      content.getElementsByTagName('LastModified')[0]?.textContent || '';
    const size = parseInt(
      content.getElementsByTagName('Size')[0]?.textContent || '0',
      10
    );

    if (key && isImageFile(key)) {
      // 썸네일만 필터링
      if (thumbnailsOnly && !key.includes('/thumb/')) {
        continue;
      }

      objects.push({
        key,
        lastModified,
        size,
        url: `${BUCKET_URL}/${encodeURIComponent(key)}`,
      });
    }
  }

  // 정렬: 최신순
  const sortedObjects = objects.sort(
    (a, b) =>
      new Date(b.lastModified).getTime() - new Date(a.lastModified).getTime()
  );

  return {
    objects: sortedObjects,
    isTruncated,
    nextMarker
  };
}
```

**변경 사항:** ~50줄 (인터페이스 10줄 + 파라미터 처리 15줄 + 페이지네이션 정보 10줄 + 반환 타입 변경 15줄)

### 2. hooks/useS3Photos.ts 업데이트

#### 2a. 페이지네이션 훅으로 전환

```typescript
import { useState, useEffect, useCallback } from 'react';
import { listS3Objects, S3Object, S3ListOptions } from '../lib/s3';

export const useS3Photos = (prefix?: string, thumbnailsOnly: boolean = false) => {
  const [photos, setPhotos] = useState<S3Object[]>([]);
  const [loading, setLoading] = useState(true);
  const [loadingMore, setLoadingMore] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(false);
  const [nextMarker, setNextMarker] = useState<string | undefined>(undefined);

  // 초기 로드
  useEffect(() => {
    const fetchInitialPhotos = async () => {
      try {
        setLoading(true);
        const result = await listS3Objects({
          prefix,
          thumbnailsOnly,
          maxKeys: 50  // 첫 50장만
        });

        setPhotos(result.objects);
        setHasMore(result.isTruncated);
        setNextMarker(result.nextMarker);
        setLoading(false);
      } catch (err) {
        console.error('S3 사진 로드 오류:', err);
        setError('사진을 불러오는 중 오류가 발생했습니다.');
        setLoading(false);
      }
    };

    fetchInitialPhotos();
  }, [prefix, thumbnailsOnly]);

  // 추가 로드
  const loadMore = useCallback(async () => {
    if (!hasMore || loadingMore) return;

    try {
      setLoadingMore(true);
      const result = await listS3Objects({
        prefix,
        thumbnailsOnly,
        maxKeys: 50,
        marker: nextMarker
      });

      setPhotos(prev => [...prev, ...result.objects]);
      setHasMore(result.isTruncated);
      setNextMarker(result.nextMarker);
      setLoadingMore(false);
    } catch (err) {
      console.error('추가 사진 로드 오류:', err);
      setError('추가 사진을 불러오는 중 오류가 발생했습니다.');
      setLoadingMore(false);
    }
  }, [prefix, thumbnailsOnly, nextMarker, hasMore, loadingMore]);

  return {
    photos,
    loading,
    loadingMore,
    error,
    hasMore,
    loadMore
  };
};
```

**변경 사항:** ~60줄 (상태 추가 15줄 + 초기 로드 20줄 + loadMore 함수 25줄)

### 3. components/MemoryTimeline.tsx 업데이트

#### 3a. 훅 사용 업데이트 (line 30)

```typescript
// Before
const { photos: historyPhotos } = useS3Photos('history/', true);

// After
const {
  photos: historyPhotos,
  loading: photosLoading,
  loadingMore,
  hasMore,
  loadMore
} = useS3Photos('history/', true);
```

#### 3b. "더보기" 버튼 UI 추가 (타임라인 하단)

타임라인 렌더링 섹션 끝부분 (line ~400)에 추가:

```typescript
{/* 타임라인 끝 */}
</div>

{/* 더보기 버튼 */}
{hasMore && (
  <div className="flex justify-center mt-8 mb-4">
    <button
      onClick={loadMore}
      disabled={loadingMore}
      className="px-6 py-3 bg-primary-600 text-white rounded-lg hover:bg-primary-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
    >
      {loadingMore ? (
        <div className="flex items-center gap-2">
          <div className="w-5 h-5 border-2 border-white border-t-transparent rounded-full animate-spin" />
          <span>추억 불러오는 중...</span>
        </div>
      ) : (
        <span>더 많은 추억 보기 ({historyPhotos.length}장 로드됨)</span>
      )}
    </button>
  </div>
)}
```

**변경 사항:** ~20줄 (훅 사용 5줄 + UI 15줄)

### 4. components/MemorySlider.tsx 업데이트 (선택)

슬라이더도 동일하게 페이지네이션 적용:

```typescript
const {
  photos: historyPhotos,
  hasMore,
  loadMore
} = useS3Photos('history/', true);

// 슬라이더 끝에 "더보기" 슬라이드 추가
{hasMore && (
  <div className="keen-slider__slide">
    <button onClick={loadMore} className="...">
      더 많은 추억 보기
    </button>
  </div>
)}
```

**변경 사항:** ~15줄

## 수정 파일 목록
1. ✅ `lib/s3.ts` - 페이지네이션 API 지원
2. ✅ `hooks/useS3Photos.ts` - loadMore 함수 추가
3. ✅ `components/MemoryTimeline.tsx` - 더보기 버튼
4. ⚠️ `components/MemorySlider.tsx` - 선택 (동일 패턴)

**총 변경:** ~145줄

## 데이터 흐름

### Before (현재)
```
페이지 로드
  ↓
S3 요청: ALL thumbnails (100+ 장)
  ↓
XML 파싱 (100+ 객체)
  ↓
정렬 + 필터링
  ↓
렌더링 (3-4초 소요)
```

### After (최적화)
```
페이지 로드
  ↓
S3 요청: max-keys=50
  ↓
XML 파싱 (50 객체만)
  ↓
정렬 + 필터링
  ↓
렌더링 (< 1초)
  ↓
사용자 "더보기" 클릭
  ↓
S3 요청: max-keys=50 + marker
  ↓
기존 배열에 추가
  ↓
점진적 렌더링
```

## 성능 영향

| 지표 | Before | After | 개선도 |
|-----|--------|-------|--------|
| 초기 객체 수 | 100+ | 50 | 50% 감소 |
| 초기 XML 크기 | ~20KB | ~10KB | 50% 감소 |
| 초기 파싱 시간 | 200-300ms | 100-150ms | 50% 개선 |
| **총 로딩 시간** | **3-4초** | **< 1초** | **70-75% 개선** |
| 추가 로드 시간 | N/A | ~500ms | 사용자 제어 |

**트레이드오프:**
- 전체 사진 보기 위해 클릭 필요 (허용 가능)
- 네트워크 요청 수 증가 (2-3회) → 총량은 동일

## 검증 방법

### 테스트 체크리스트
- [ ] 초기 로딩 < 1초
- [ ] 50장 정확히 로드됨
- [ ] "더보기" 버튼 표시 (`hasMore === true`)
- [ ] 추가 로드 정상 작동
- [ ] 모든 사진 로드 시 버튼 사라짐
- [ ] 기존 썸네일→원본 기능 유지
- [ ] 모바일에서도 정상 작동

### 실행 방법
```bash
npm run dev
```

브라우저에서:
1. 개발자 도구 Network 탭 열기
2. 페이지 로드 시 S3 요청 확인:
   - `?prefix=history/&max-keys=50` 확인
   - 응답에 `IsTruncated: true` 확인
3. 타임라인 스크롤하여 "더보기" 버튼 확인
4. 버튼 클릭 시 추가 요청 확인:
   - `?prefix=history/&max-keys=50&marker=...` 확인
5. 로딩 시간 측정 (Network 탭의 Finish 시간)

### 성능 측정
```javascript
// 개발자 콘솔에서 실행
performance.mark('photos-start');
// 사진 로드 후
performance.mark('photos-end');
performance.measure('photos-load', 'photos-start', 'photos-end');
console.log(performance.getEntriesByName('photos-load')[0].duration);
```

목표: < 1000ms

## 리스크 평가
**위험도: 낮음**
- S3 표준 API 기능 사용 (신뢰성 높음)
- 기존 썸네일 우선 로딩 유지
- 점진적 개선 (기능 추가만)
- 하위 호환성 유지 (maxKeys 기본값)
- 쉬운 롤백 가능

## 향후 확장 가능성

### Phase 2: 무한 스크롤 (선택)
"더보기" 버튼이 잘 작동하면 무한 스크롤로 전환 가능:

```typescript
import { useInView } from 'react-intersection-observer';

const { ref, inView } = useInView({
  threshold: 0.5,
});

useEffect(() => {
  if (inView && hasMore && !loadingMore) {
    loadMore();
  }
}, [inView, hasMore, loadingMore, loadMore]);

// 렌더링
<div ref={ref} className="h-20" /> {/* 감지 영역 */}
```

### Phase 3: 가상 스크롤 (100+ 장 이후)
매우 많은 사진(500+)인 경우 react-window 도입:
- 메모리 사용량 최적화
- 렌더링 성능 개선
- 스크롤 성능 향상

## 구현 순서
1. `lib/s3.ts` - 페이지네이션 API 추가
2. `hooks/useS3Photos.ts` - loadMore 로직
3. `components/MemoryTimeline.tsx` - UI 통합
4. 로컬 테스트 및 성능 측정
5. (선택) `components/MemorySlider.tsx` 적용
6. (선택) 무한 스크롤 전환

## 예상 사용자 경험 개선

### Before
```
사용자: 타임라인 페이지 오픈
  → 3-4초 대기 (빈 화면)
  → 모든 사진 한번에 로드
  → "오래 걸리네..."
```

### After
```
사용자: 타임라인 페이지 오픈
  → < 1초 안에 최근 50장 표시
  → "빠르다!"
  → 필요시 "더보기" 클릭
  → 추가 50장 로드 (~500ms)
  → "원하는 만큼만 보면 되네"
```

## 구현 코드 요약

### 핵심 변경사항
1. **S3 API**: 기존 단순 fetch → 페이지네이션 지원
2. **훅**: 단순 데이터 fetcher → 점진적 로딩 관리자
3. **컴포넌트**: 정적 리스트 → 동적 로딩 UI

### 코드 복잡도
- 기존: 간단 (100줄)
- 변경 후: 중간 (245줄)
- 증가량: 145줄 (58% 증가)
- 복잡도 대비 가치: **매우 높음** (70% 성능 개선)

## 결론
최소한의 코드 변경(145줄)으로 초기 로딩 시간을 70% 단축할 수 있습니다. "더보기" 버튼 방식은 구현이 간단하면서도 효과적이며, 추후 무한 스크롤이나 가상 스크롤로 쉽게 확장 가능합니다.
